%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  File:   introduction.tex                                                    %
%  Author: Cayden Lund (cayden.lund@utah.edu)                                  %
%          Student, University of Utah                                         %
%                                                                              %
%  Brief:  Contains the introductory section.                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{sec:introduction}

\subsection{The Murphi Modeling Language}\label{subsec:the-murphi-modeling-language}

Model checking plays a vital role in ensuring the reliability and correctness
of complex systems, ranging from hardware designs to software applications.
As systems grow increasingly intricate and interconnected, the potential for
errors and vulnerabilities also escalates.
Model checking provides a systematic and formal approach to identify design
flaws, uncover subtle bugs, and verify the adherence of systems to desired
specifications.
By exploring the state space of a model and analyzing the system's behavior
against specified properties, model checking aids in identifying critical
issues that might lead to malfunctions, security breaches, or safety hazards.
The significance of model checking extends beyond the initial development
phase, as it can also be employed during system evolution and maintenance to
detect unintended consequences of modifications and ensure the preservation
of system correctness.
With its ability to provide rigorous analysis and verification, model
checking plays a pivotal role in improving system dependability and reducing
the risk of costly errors and failures.

To facilitate the model-checking process, several modeling languages have been
developed, each designed to capture the essential characteristics of a system
under scrutiny.
One such language is the Murphi modeling language, which has gained popularity
due to its intuitive syntax and powerful expressive capabilities.

The Murphi modeling language provides a formal framework for describing system
behavior by specifying its state space and the rules governing state
transitions.
By defining the system's properties and constraints, engineers can create
precise and detailed models that capture the essential aspects of the system's
functionality.

Moreover, the rigidity of the Murphi modeling language has led to the
development of various model-checking tools specifically tailored for Murphi
models.
These tools, such as \texttt{rumur} and \texttt{romp}, offer different
strategies and algorithms to explore and analyze the state space of Murphi
models.
By leveraging these tools, engineers can efficiently verify the correctness
and identify potential flaws in their systems.

\subsection{\texttt{rumur} and \texttt{romp}}\label{subsec:rumur-and-romp}

In the context of Murphi model checking, two notable tools have gained
prominence: \texttt{rumur} and \texttt{romp}.
These tools offer different approaches to model checking,
catering to varying requirements and constraints of the system being analyzed.

\texttt{rumur} performs an explicit enumeration of the entire state space,
exhaustively examining all possible system states.
This exhaustive approach provides a definitive answer regarding the presence of
flaws in the model.
It is particularly well-suited for smaller models where the state space can be
completely covered.

In contrast, \texttt{romp} adopts a parallel random walk strategy for model
checking.
By exploring the state space in a randomized and parallelized manner,
\texttt{romp} can quickly cover an enormous state space.
However, due to its probabilistic nature, it cannot offer strong guarantees of
complete bug-freedom in the model.

The choice between \texttt{rumur} and \texttt{romp} depends on the
characteristics of the system being analyzed.
For smaller models, where it is feasible to exhaustively cover the state space,
\texttt{rumur} can provide a definitive answer on the presence of flaws.
On the other hand, for models with enormous state spaces where exhaustive
enumeration is infeasible, \texttt{romp} offers a practical and scalable
approach to detect potential bugs.

In this paper, we present a practical exploration of scalable model checking
using \texttt{rumur} and \texttt{romp}.
We demonstrate their effectiveness by examining two buggy models:
a tic-tac-toe strategy and a model for the leader election protocol.
Through these case studies, we evaluate the capabilities of
\texttt{rumur} and \texttt{romp} in identifying and correcting flaws,
shedding light on their respective strengths and limitations in different
scenarios.

\subsection{Supporting Files}\label{subsec:supporting-files}

In support of this paper, several files have been provided to facilitate the
reproduction and understanding of the presented work.
These files are located in the \texttt{Models/} directory and serve various
purposes in the context of the case studies.
The following supporting files are included:

\begin{itemize}
    \item \texttt{tictactoe\_buggy.m}: This file contains the initial version
    of the buggy tic-tac-toe strategy that was subjected to debugging and
    analysis in this paper.
    It serves as a starting point for the investigation and showcases the
    flaws in the original strategy.

    \item \texttt{tictactoe\_fixed.m}: This file contains the corrected
    version of the tic-tac-toe strategy after the debugging process.
    It represents the improved strategy that addresses the identified flaw
    and ensures a winning or tied gameplay.

    \item \texttt{leaderelection\_buggy.m}: The \texttt{leaderelection\_buggy.m}
    file contains the original version of the buggy leader election protocol.
    It is the basis for the analysis and correction of the protocol,
    and has a bug in its implementation that we identify and correct.

    \item \texttt{leaderelection\_fixed.m}: This file includes the fixed version
    of the leader election protocol.

    \item \texttt{Makefile}: The \texttt{Makefile} is a utility file provided
    to automate the building and compilation of the model-checking executables.
    It simplifies the process of generating the necessary binaries for
    running the analysis on the provided models.
\end{itemize}

These supporting files, along with the accompanying explanations and
discussions in the paper, enable readers to reproduce the experiments,
examine the model structures, and gain a comprehensive understanding of the
presented case studies.
